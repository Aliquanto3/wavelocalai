# Contexte et Objectif

Je développe **WaveLocalAI**, un Workbench IA local fonctionnel mais encore au stade "projet de développeur". Mon objectif est de le transformer en produit logiciel stable, reproductible et distribuable (Production-Ready).

**Stack technique :** Python, Streamlit, PyInstaller, GitHub Actions

**Ton rôle :** Senior DevOps Engineer et Release Manager spécialisé dans l'écosystème Python, obsédé par la stabilité et la Developer Experience.

---

# Ta Mission

Analyse le code source fourni ci-dessous et **génère le code complet** des fichiers de configuration manquants pour atteindre un niveau de qualité industriel.

**Important :** Je veux du CODE prêt à l'emploi, pas seulement des conseils.

---

# Livrables Attendus

Pour **chaque livrable** ci-dessous, structure ta réponse ainsi :
```
## [Numéro]. [Titre du Livrable]

### Pourquoi c'est nécessaire
[Explication concise : 2-3 phrases max]

### Fichier de Configuration
[Code complet dans un bloc de code avec le nom du fichier en commentaire]

### Instructions de Mise en Place
- Emplacement : [chemin du fichier]
- Commandes : [commandes exactes à exécuter]
```

---

## Livrable 1 : Pipeline CI/CD (GitHub Actions)

**Fichier attendu :** `.github/workflows/ci.yml`

**Exigences fonctionnelles :**
- Déclenchement : Push et Pull Request vers `main`
- Matrice de test : Python 3.10 et 3.11
- Étapes obligatoires :
  1. Installation des dépendances
  2. Analyse statique (Ruff ou Flake8) avec échec en cas d'erreur
  3. Tests unitaires avec pytest
- Bonus : Cache des dépendances pour accélérer les builds

---

## Livrable 2 : Packaging Exécutable (PyInstaller)

**Fichiers attendus :** `wavelocalai.spec` OU `build_executable.py`

**Défi technique Streamlit :**
Streamlit est complexe à compiler car il nécessite :
- L'inclusion des assets cachés (`streamlit/static`, `streamlit/runtime`)
- Un entrypoint personnalisé qui lance `sys.executable -m streamlit run app.py`

**Exigences fonctionnelles :**
- Création d'un exécutable autonome (Windows `.exe` / macOS `.app`)
- Gestion correcte des chemins relatifs pour les fichiers de données
- Instructions claires pour :
  1. Installer PyInstaller
  2. Lancer le build
  3. Tester l'exécutable généré

---

## Livrable 3 : Verrouillage des Dépendances

**Stratégie attendue :**
- Analyse de mon `requirements.txt` actuel (fourni ci-dessous avec le code)
- Proposition d'une solution de verrouillage (exemple : `pip-tools` avec fichiers `.in` et `.txt` séparés)
- Génération du fichier de configuration nécessaire

**Exigences :**
- Explication claire de pourquoi le verrouillage est critique en production (reproductibilité, sécurité)
- Workflow complet : comment régénérer le lockfile lors d'un ajout de dépendance

---

## Livrable 4 : Hooks Pre-commit

**Fichier attendu :** `.pre-commit-config.yaml`

**Exigences fonctionnelles :**
- Formatage automatique du code (black ou ruff format)
- Détection de secrets/clés privées (detect-secrets ou équivalent)
- Blocage des fichiers > 5MB
- Vérification de la syntaxe YAML/JSON
- Trailing whitespace, end-of-file-fixer

---

# Contraintes Additionnelles

1. **Tous les fichiers doivent être testables immédiatement** (pas de TODO, pas de placeholders)
2. **Commente les parties critiques** pour faciliter la maintenance future
3. **Indique les versions précises** des outils dans les configs (ex: `ruff==0.1.9`)
4. Si une dépendance manque dans mon code source, **signale-le explicitement**

---

# Format de Réponse Final

Structure ta réponse avec :
1. Un tableau récapitulatif des fichiers générés
2. Les 4 livrables détaillés (format ci-dessus)
3. Une section "Prochaines Étapes" avec l'ordre d'exécution recommandé

Commence maintenant.
